//! Autogenerating trait implementations for constrained strings
use std::fmt;

/// The `Error` type of `TryFrom<String> for $t` implementations generated by
/// `validstr!()`
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TryFromStringError<E> {
    /// The error returned by `$validator`
    pub inner: E,

    /// The string that failed validation
    pub string: String,
}

impl<E: fmt::Display> fmt::Display for TryFromStringError<E> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "failed to parse {:?}: {}", self.string, self.inner)
    }
}

impl<E: std::error::Error> std::error::Error for TryFromStringError<E> {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.inner.source()
    }
}

/// Autogenerate trait implementations for constrained/"validated" strings
///
/// Given:
///
/// - A type `$t` defined as a tuple struct whose only field is `String`
///
/// - An error type `$err`
///
/// - A function name `$validator` with the signature `(&str) -> Result<(),
///   $err>`
///
/// `validstr($t, $err, $validator)` defines a number of trait implementations
/// for `$t` that allow for, among other things:
///
/// - Converting `$t` and `&$t` to a `String`
///
/// - Converting `&str` and `String` values to `$t` if & only if they are
///   accepted by `$validator`
///
///     - The error types returned by these operations are `$err` and
///       `TryFromStringError<$err>`, respectively.
///
/// - Comparing `$t` to string values
///
/// - Dereferencing `$t` as a `&str`
macro_rules! validstr {
    ($t:ident, $err:ty, $validator:ident) => {
        impl $t {
            pub fn into_inner(self) -> String {
                self.0
            }

            pub fn as_str(&self) -> &str {
                &self.0
            }
        }

        impl From<$t> for String {
            fn from(value: $t) -> String {
                value.0.into()
            }
        }

        impl From<&$t> for String {
            fn from(value: &$t) -> String {
                value.0.clone()
            }
        }

        impl std::fmt::Debug for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{:?}", self.0)
            }
        }

        impl std::fmt::Display for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0)
            }
        }

        impl PartialEq<String> for $t {
            fn eq(&self, other: &String) -> bool {
                &self.0 == other
            }
        }

        impl PartialEq<str> for $t {
            fn eq(&self, other: &str) -> bool {
                self.0 == other
            }
        }

        impl<'a> PartialEq<&'a str> for $t {
            fn eq(&self, other: &&'a str) -> bool {
                &self.0 == other
            }
        }

        impl AsRef<str> for $t {
            fn as_ref(&self) -> &str {
                self.0.as_ref()
            }
        }

        impl std::ops::Deref for $t {
            type Target = str;

            fn deref(&self) -> &str {
                &*self.0
            }
        }

        impl std::str::FromStr for $t {
            type Err = $err;

            fn from_str(s: &str) -> Result<$t, $err> {
                match $validator(s) {
                    Ok(()) => Ok($t(s.into())),
                    Err(e) => Err(e),
                }
            }
        }

        impl TryFrom<String> for $t {
            type Error = crate::validstr::TryFromStringError<$err>;

            fn try_from(s: String) -> Result<$t, Self::Error> {
                match $validator(&s) {
                    Ok(()) => Ok($t(s)),
                    Err(inner) => Err(crate::validstr::TryFromStringError { inner, string: s }),
                }
            }
        }
    };
}
