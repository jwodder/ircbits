//! Autogenerating trait implementations for constrained strings
use std::fmt;

/// The `Error` type of `TryFrom<String> for $t` implementations generated by
/// `validstr!()`
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct TryFromStringError<E> {
    /// The error returned by `$validator`
    pub inner: E,

    /// The string that failed validation
    pub string: String,
}

impl<E: fmt::Display> fmt::Display for TryFromStringError<E> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "failed to parse {:?}: {}", self.string, self.inner)
    }
}

impl<E: std::error::Error> std::error::Error for TryFromStringError<E> {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.inner.source()
    }
}

/// Autogenerate trait implementations for constrained/"validated" strings
///
/// Given:
///
/// - A type `$t` defined as a tuple struct whose only field is `String`
///
/// - An error type `$err`
///
/// - A function name `$validator` with the signature `(&str) -> Result<(),
///   $err>`
///
/// `validstr($t, $err, $validator)` defines a number of trait implementations
/// for `$t` that allow for, among other things:
///
/// - Converting `$t` and `&$t` to a `String`
///
/// - Converting `&str` and `String` values to `$t` if & only if they are
///   accepted by `$validator`
///
///     - The error types returned by these operations are `$err` and
///       `TryFromStringError<$err>`, respectively.
///
/// - Comparing `$t` to string values
///
/// - Dereferencing `$t` as a `&str`
macro_rules! validstr {
    ($t:ident, $err:ty, $validator:ident) => {
        impl $t {
            pub fn into_inner(self) -> String {
                self.0
            }

            pub fn as_str(&self) -> &str {
                &self.0
            }
        }

        impl From<$t> for String {
            fn from(value: $t) -> String {
                value.0.into()
            }
        }

        impl From<&$t> for String {
            fn from(value: &$t) -> String {
                value.0.clone()
            }
        }

        impl std::fmt::Debug for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{:?}", self.0)
            }
        }

        impl std::fmt::Display for $t {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", self.0)
            }
        }

        impl PartialEq<String> for $t {
            fn eq(&self, other: &String) -> bool {
                &self.0 == other
            }
        }

        impl PartialEq<str> for $t {
            fn eq(&self, other: &str) -> bool {
                self.0 == other
            }
        }

        impl<'a> PartialEq<&'a str> for $t {
            fn eq(&self, other: &&'a str) -> bool {
                &self.0 == other
            }
        }

        impl AsRef<str> for $t {
            fn as_ref(&self) -> &str {
                self.0.as_ref()
            }
        }

        impl std::ops::Deref for $t {
            type Target = str;

            fn deref(&self) -> &str {
                &*self.0
            }
        }

        impl std::str::FromStr for $t {
            type Err = $err;

            fn from_str(s: &str) -> Result<$t, $err> {
                match $validator(s) {
                    Ok(()) => Ok($t(s.into())),
                    Err(e) => Err(e),
                }
            }
        }

        impl TryFrom<String> for $t {
            type Error = crate::validstr::TryFromStringError<$err>;

            fn try_from(string: String) -> Result<$t, Self::Error> {
                match $validator(&string) {
                    Ok(()) => Ok($t(string)),
                    Err(inner) => Err(crate::validstr::TryFromStringError { inner, string }),
                }
            }
        }
    };
}

macro_rules! strserde {
    ($t:ty, $expecting:literal) => {
        #[cfg(feature = "serde")]
        #[cfg_attr(docsrs, doc(cfg(feature = "serde")))]
        impl serde::Serialize for $t {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                serializer.serialize_str(self.as_ref())
            }
        }

        #[cfg(feature = "serde")]
        #[cfg_attr(docsrs, doc(cfg(feature = "serde")))]
        impl<'de> serde::Deserialize<'de> for $t {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::de::Deserializer<'de>,
            {
                struct Visitor;

                impl serde::de::Visitor<'_> for Visitor {
                    type Value = $t;

                    fn expecting(
                        &self,
                        formatter: &mut std::fmt::Formatter<'_>,
                    ) -> std::fmt::Result {
                        formatter.write_str($expecting)
                    }

                    fn visit_str<E>(self, input: &str) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        input
                            .parse::<$t>()
                            .map_err(|_| E::invalid_value(serde::de::Unexpected::Str(input), &self))
                    }

                    fn visit_string<E>(self, input: String) -> Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        <$t>::try_from(input).map_err(|e| {
                            E::invalid_value(serde::de::Unexpected::Str(&e.string), &self)
                        })
                    }
                }

                deserializer.deserialize_string(Visitor)
            }
        }
    };
}
